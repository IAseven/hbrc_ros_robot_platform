#!/bin/bash

# This file is licensed using the "MIT License" below:
#
####################################################################################################
#
# MIT License
#
# Copyright 2020 Home Brew Robotics Club
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to the following
# conditions:
# 
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
# PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
# FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
####################################################################################################

# Shell scripts are notoriously difficult to read and debug.
# To aid in reading/debugging this script, there are deliberately plenty of comments.
# Speak of comments, the pronouns "we" and "you" are used liberally.
# The "we" pronoun refers to the people who develop/maintain this file
# and the pronoun "you" to refers to you, the reader(s) of this code.

# As an overview, this is one shell script that is executed twice.  The first time it
# just ensures that git is installed, we are on the master branch and forces the master
# branch to be updated.  Updating the master branch may update this file, so we recursively
# call this shell script again to ensure that we have the most up-to-date version of this
# script.  You really should not notice that there are two shells running instead of just one.

# In general, turning on debugging flags helps to debug shell scripts.  The four flags
# below are really helpful.  That being said, it should be mentioned that the Python
# Virtual Environments Wrapper breaks if these flags are set.  So, right before we actually
# try to use any python virtual environments stuff, we turn need to turn these flags off.
# This causes all of the python stuff to be pushed as far back as possible in this script.
set -x           # Trace execution.
set -e           # Exit immediately on error result.
set -o pipefail  # Fail if any commands in a pipeline fail.
set -u           # Treat unset variables as an error.

# The `set -u` option causes problems when you are trying to detect whether a variable is defined
# or not.  If you try to directly access the an undefined variable, the `set +u` will correctly
# generate a failure.  The solution to this problem is a very obscure corner of bash called
# "Parameter Expansion".  The syntax `${VARIABLE_NAME+WORD}` will either return value of
# `VARIABLE_NAME` (i.e. `"$VARIABLE_NAME"`) or WORD (i.e. `"WORD"`) depending upon whether
# `VARIABLE_NAME` is set or not.  This is strange stuff.  The follow code snippet shows what
# happens:
#
#     #!/bin/bash
#     set -u
#     if [ -z "${FOO+EXISTS}" ]
#     then
#         echo FOO does not EXIST
#     else
#         echo FOO EXISTS
#     fi
#
#     if [ -z "${HOME+EXISTS}" ]
#     then
#         echo HOME does not EXIST
#     else
#         echo HOME EXISTS
#     fi
#
# When the code is executed, the following comes out:
#     
#     FOO does not EXIST
#     HOME EXISTS
#
# So now you know what that strange bash syntax is being used for.  By the way, the "+EXISTS"
# could be "+ANYTHING", but "+EXISTS" seems more descriptive.

# Set all of the install flags to the empty string.  Set to "yes" to enable.
# The following test will do the logical OR of given flags `if [ -n "$EE$ME" ]`.
# It is basically the same as `if [ -n "$EE" ] || [ -n "ME" ]`, but little shorter:
DEV=""   # Development
EE=""    # Electrical Engineering
ME=""    # Mechanical Engineering
SW=""    # Software
WF=""    # Workflow
PASS2=""  # Secret flag to enter the recursive portion of this shell script

# Define commands common to both passes:
GIT_PULL="git pull --ff"

# Check for git config --global user/email

# Process the arguments specified by the user:
if [ "$#" = "0" ]
then
    # No arguments produces an overview:
    echo "Usage: install [ all | most | dev | ee | me | sw ]*"
    echo "where:"
    echo "all    Installs everything"
    echo "most   Installs everything but dev"
    echo "dev    Installs the development workflow (a personal Git.Hub account is required.)"
    echo "ee     Installs all of the software needed for electrical engineering"
    echo "me     Installs all of the software needed for mechanical engineering"
    echo "sw     Installs all of the software needed for software development"
    # pass2      Skips the first phase of the installation script
else
    # Iterate over each `flag` from the command line:
    for flag in "$@"
    do
	#echo "flag=$flag"
	case "$flag" in
	    all ) EE="yes"
		  ME="yes"
		  SW="yes"
		  DEV="yes"
		  ;;
	    most ) EE="yes"
		   ME="yes"
		   SW="yes"
		   ;;
	    dev ) DEV="yes"
		 ;;
	    ee ) EE="yes"
		 ;;
	    me ) ME="yes"
		 ;;
	    sw ) SW="yes"
		 ;;
            none )
		;;
	    pass2 ) PASS2="yes"
		    ;;
	    *) echo "$flag is not allowed.  Only all, most, dev, ee, me, and sw are allowed."
	       exit 1
	       ;;
	esac
    done
    # For debugging only:
    echo "DEV=$DEV"
    echo "EE=$EE"
    echo "ME=$ME"
    echo "SW=$SW"
    echo "PASS2=$PASS2"
fi

# Defining the various critical directories gets duplicated for both pass 1 and pass 2.
#
# Find the directory that contains this shell script.  For reference see:
#    https://stackoverflow.com/questions/59895/how-to-get-the-source-directory-of-a-bash-script-from-within-the-script-itself
# We are using the single line solution rather than the multi-line version (which is overkill.)
BIN_DIRECTORY="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
echo "BIN_DIRECTORY=$BIN_DIRECTORY"

# Define the two parent directories:
HR2_DIRECTORY="$( realpath $BIN_DIRECTORY/.. )"
REPOSITORIES_DIRECTORY="$( realpath $HR2_DIRECTORY/.. )"
# echo "HR2_DIRECTORY=$HR2_DIRECTORY"
echo "REPOSITORIES_DIRECTORY=$REPOSITORIES_DIRECTORY"


# Pass 1 focuses on making sure that the master branch is up to date:
# Always `cd` to `$HR2_DIRECTORY`.
cd $HR2_DIRECTORY

if [ -z "$PASS2" ]
then
    # Pass1:
    echo "Pass 1"

    # The master branch is configured to be "read-only in the sense that it is *NEVER* modified on
    # the local machine.  Modifications on other branches are allowed, but not to the local master.
    # What this means is that it is always safe to do a `git pull` into the master branch.  We do
    # not over think this, we just attempt to checkout master and do the pull.  If it fails, we let
    # you know that the checkout failed.  This functionality is embedded in the fairly complicated
    # shell function below.

    # Usage `repository_update REPOSITORY_DIRECTORY`
    # Returns 0 for success and > 0 for errors:
    function repository_update() {
	# Step 1: Extract the REPOSITORY_DIRECTORY function argument:
        echo "Step 1"
	REPOSITORY_DIRECTORY=$1
	#debug: echo "REPOSITORY_DIRECTORY=$REPOSITORY_DIRECTORY"
	ERROR_MESSAGE='Update of repository for "$REPOSITORY_DIRECTORY" will not happen.'
	# CWD means Current Working Directory:
	CWD="$(pwd)"

	# Step 2: Ensure that we have `git` is installed:
	WHICH_GIT="$(which git)"
	#debug: echo "WHICH_GIT=$WHICH_GIT"
	if [ -z "$WHICH_GIT" ]
	then
	    echo "!!!!!!!!!!!!!!!! \`git\` program is not installed yet."
            echo "$ERROR_MESSAGE"
	    return 1
	fi

	# Step 2: Ensure that REPOSITORY_DIRECTORY exists and is a directory.
        echo "Step 2"
	if [ ! -d "$REPOSITORY_DIRECTORY" ]
	then
	    echo "!!!!!!!!!!!!!!!! \`$REPOSITORY_DIRECTORY\` is not a directory."
            echo "ERROR_MESSAGE"
	    return 2
	fi

	# Step 3: Change over to REPOSITORY_DIRECTORY and find the REPOSITORY_ROOT.  From here on,
	# before returning we have to return to the original CWD directory on an error.
        echo "Step 3"
	cd "$REPOSITORY_DIRECTORY"
	# The `2>/dev/null` suppresses error messages:
	REPOSITORY_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"
	#debug: echo "REPOSITORY_ROOT=$REPOSITORY_ROOT"
	if [ -z "$REPOSITORY_ROOT" ]
	then
	    echo "!!!!!!!!!!!!!!!! \`$REPOSITORY_DIRECTORY\` is not part of a git repository."
            echo "$ERROR_MESSAGE"
            cd "$CWD"
	    return 3
	fi

	# Step 4: Determine if with we have either an `upstream` or `origin` remote.  If the
	# repository has been freshly cloned, it will have a remote of `origin`.  If the
	# `hr2_install dev` has been specified it has been set up as `upstream`.  If neither
	# remote is present, there is no way to recover and we are done.  We may have the
	# `set -o pipefail` option enabled and the code below avoids problems with `grep` not
	# finding anything.
        echo "Step 4"
	UPSTREAM_REMOTE="$( ( cd $HR2_DIRECTORY ; echo $(git remote | grep upstream ) ) )"
	ORIGIN_REMOTE="$(   ( cd $HR2_DIRECTORY ; echo $(git remote | grep origin   ) ) )"
	STAGING_REMOTE="$(  ( cd $HR2_DIRECTORY ; echo $(git remote | grep staging  ) ) )"
	echo "ORIGIN_REMOTE=$ORIGIN_REMOTE"
	echo "UPSTREAM_REMOTE=$UPSTREAM_REMOTE"
	if [ -n "$UPSTREAM_REMOTE" ]
	then
	    ACTUAL_REMOTE="$UPSTREAM_REMOTE"
	elif [ -n "$ORIGIN_REMOTE" ]
	then
	    ACTUAL_REMOTE="$ORIGIN_REMOTE"
	else
	    echo "!!!!!!!!!!!!!!!! There is no remote repository named \`upstream\`" \
		 "or \'origin\' defined for repository \'$REPOSITORY_ROOT\'."
	    echo "$ERROR_MESSAGE"
	    cd "$CWD"
	    return 4
	fi

	# Step 5: Determine if we have a `master` branch.  If not, things pretty screwed up.
	# `git branch` returns an alphabetized of branches of the form:
	#
	#       branch1
	#     * branch2
	#       ...
	#       branchN
	#
	# The currently active branch will have an asterisk in front of it.
	# We feed the output of `git branch` through `sed` to strip off the first two
	# characters and search for `master`:
        echo "Step 5"
	MASTER_BRANCH="$(git branch | sed 's,^..,,g' | grep master)"
	#debug: echo "MASTER_BRANCH=$MASTER_BRANCH"
	if [ -z "$MASTER_BRANCH" ]
	then
	    echo "!!!!!!!!!!!!!!!! There is no \`master\` branch in repository \`$REPOSITORY_ROOT\`."
	    echo "$ERROR_MESSAGE"
	    cd "$CWD"
	    return 5
	fi

	# Step 6: Get current branch name and a list of uncommitted files.  If we are not on the
	# `master` branch we will temporarily switch over to the `master` branch, attempt to update
	# master and return the current branch.  This is easily said, not not so easily done.
	# If we are already on the `master` branch we can avoid the hassle of switching branches:
	# For reference:
	#   https://stackoverflow.com/questions/6245570/how-to-get-the-current-branch-name-in-git
	# explained how to get the CURRENT_BRANCH name.  It is obscure:
	CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
	#debug: echo "CURRENT_BRANCH=$CURRENT_BRANCH"
	# Likewise getting the UNCOMMITTED_FILES is pretty obscure as well:
	UNCOMMITTED_FILES="$(git diff --name-only HEAD)"
	#debug: echo "UNCOMMITTED_FILES=$UNCOMMITTED_FILES"
	echo "Step 6"
	echo "Starting to update the master branch."
	if [ "$CURRENT_BRANCH" != "master" ]
	then
	    # Step 6: We have uncommitted files in this repository. We need to
	    # temporarily "stash" them before changing over to `master` branch:
	    if [ -n "$UNCOMMITTED_FILES" ]
	    then
		echo "Temporarily stashing uncommitted files for \`$CURRENT_BRANCH\` branch."
		git stash > /dev/null # Suppress the messages.
	    fi

	    # Step 7: Temporarily switch over to `master` branch:
	    echo "Temporarily switching over to master branch from $CURRENT_BRANCH branch."
            # Suppress the messages:
	    git checkout master > /dev/null 2>/dev/null
	    # From here on out, if we encounter an error we have return back to `$CURRENT_BRANCH`
	    # **AND** unstash the uncommitted files.
	fi

	# Step 7: Finally perform the git pull from the upstream/orign repository into
	# the master branch.  Because the local master branch has been configured
	# to disallow commits, in theory, there can be no can be no merge conflicts:
	echo "Step 7"
        git checkout master
	$GIT_PULL "$ACTUAL_REMOTE" master # 2>/dev/null 1>/dev/null # Suppress the output
	echo "master branch should be up to date"

	# When you do a `git status` in the master branch it will complain about the
	# staging/master branch being seriously out of date.  We solve this by pushing
	# up to staging/master.  We do not really need a copy up there, but it does not
	# hurt and avoids an annoying and confusing message:
	if [ -n "$STAGING_REMOTE" ]
	then
	    git push -u "$STAGING_REMOTE" master
	fi

	# Step 8: Now we return to the original branch we started (if necessary):
	echo "Step 8"
	if [ "$CURRENT_BRANCH" != "master" ]
	then
	    echo "Switch from `master` branch back to $CURRENT_BRANCH branch."
	    git checkout $CURRENT_BRANCH > /dev/null 2>/dev/null # Suppess the messages

	    # Step 9: Now restore the branch to the way it was:
	    if [ -n "$UNCOMMITTED_FILES" ]
	    then
		echo "Restore any previously uncommitted files."
		git stash pop > /dev/null  # `> /dev/null` suppresses an unneeded `git status`
	    fi

	    # We are back in CURRENT_BRANCH with any uncommitted files restored.
	fi
	
	# The following code merges to the CURRENT_BRANCH, which is currently not enabled:
	#    # The following is a references (* is the one selected):
	#    #
	#    #     * https://code-maven.com/git-check-for-conflicts-before-merge
	#    #       https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option
	#    #       https://stackoverflow.com/questions/964876/head-and-orig-head-in-git
	#    #
        #    # Now figure out if a merge from master will have any conflicts.
	#    # This is done by doing a `git merge --no-commit`, followed by a
	#    # `git merge -abort`.  The return code from the `--no-commit`
	#    # is used to decide whether to do the actual merge or not.
	#    # If no conlicts will occur, perform the merge to this branch:
	#    echo "Performing test merge from master branch to $CURRENT_BRANCH."
	#    if git merge --no-commit --no-ff master > /dev/null 2>/dev/null # Suppress messages
	#    then
	#	echo "Test merge shows no problems.  Undo test merge and do it for real."
	#	git merge --abort 2>/dev/null  # `2>/dev/null` suppresses "fatal: ...." message
	#	echo "Performing the actual merge from the master branch to $CURRENT_BRANCH branch."
	#	# Suppress error messages:
	#	git merge master --commit --no-ff --no-edit > /dev/null 2>/dev/null
	#    else
	#	echo "Test merge shows there will be issue merging master branch" \
	#	     " to $CURRENT_BRANCH branch."
	#	echo "Undoing the test merge."
	#	git merge --abort
	#	echo "Please add your modified files into your branch with git add."
	#	echo "When they are all added, please do a git commit."
	#	echo "Then rerun the shell script again."
	#    fi
	#fi

	# We are done, so return to CWD and return:
	cd "$CWD"
        echo "Done"
	return 0
    }
 
    # Make sure that `git` exists:
    if [ -z "$(which git)" ]
    then
	echo "The \`git\` program does not appear to be installed.  This should not happen!"
        echo "Please run the command \`sudo\` apt install git\` to ensure \`git\` is installed."
	echo "Stopping for now."
	exit 1
    fi
    
    # Now figure out what the remotes to use.  When the repository is first cloned
    # it shows up with a remote named `origin`.  Whenever the user gets around to doing an
    # `hr_install dev`, remote is switched over to `upstream`.  We just need to figure which
    # one it is.
    UPSTREAM_REMOTE="$( ( cd $HR2_DIRECTORY ; echo $(git remote | grep upstream) ) )"
    ORIGIN_REMOTE="$(   ( cd $HR2_DIRECTORY ; echo $(git remote | grep origin  ) ) )"
    if [ -n "$UPSTREAM_REMOTE" ]
    then
	ACTUAL_REMOTE="$UPSTREAM_REMOTE"
    elif [ -n "$ORIGIN_REMOTE" ]
    then
	ACTUAL_REMOTE="$ORIGIN_REMOTE"
    else
	echo "For some weird reason we can not find a remote repository named either"
	echo "\`upstream\` or \`origin\`.  Run \`git remote -v\` to get a list of remotes."
	echo "For now, this script can not continue and is immediately stopping."
	exit 2
    fi

    # In theory, there the local copy of the `master` branch is locked down and can not
    # be branched because we install a pre-commit hook to disallow commits to the `master`
    # branch (see further below.)   This means that a `git pull` should always succeed.
    repository_update "$HR2_DIRECTORY"
	
    # Now this file may have been updated as a result of the `git pull`, so we recursively
    # call the this script (which may have been updated):
    echo "Starting pass2"
    # The "secret" pass2 argument forces us to do the second pass:
    $BIN_DIRECTORY/hr2_install $@ pass2

    # We have now returned from the recursive call and can wrap things up.
    echo "Requested installation should be complete."
    exit 0
fi

# Pass2 gets rolling here:
# Now we should be running the very most up-to-date version of this script file.
echo "................................................................"
echo "We are doing Pass2"

# For debugging only:
echo "DEV=$DEV"
echo "EE=$EE"
echo "ME=$ME"
echo "SW=$SW"
echo "PASS2=$PASS2"

# Determine which remotes exist:
UPSTREAM_REMOTE="$( ( cd $HR2_DIRECTORY ; echo $(git remote | grep upstream ) ) )"
ORIGIN_REMOTE="$(   ( cd $HR2_DIRECTORY ; echo $(git remote | grep origin   ) ) )"
STAGING_REMOTE="$(  ( cd $HR2_DIRECTORY ; echo $(git remote | grep staging  ) ) )"
echo "UPSTREAM_REMOTE=$UPSTREAM_REMOTE"
echo "ORIGIN_REMOTE=$ORIGIN_REMOTE"
echo "STAGING_REMOTE=$STAGING_REMOTE"

# Set up some convenience variables:
# Set `SOURCE_BASHRC` later on to remind the user to type `source ~/.bashrc`:
SOURCE_BASHRC=""
# `PYTHON_NEEDED` is a flag that is not empty if python is needed.
PYTHON_NEEDED="$EE$ME$SW"

# Make sure that the HOME environment variable is defined because we really need it:
if [ -z "${HOME+EXISTS}" ]
then
    echo "Weird!!  \`HOME\` is not defined!!  Things are really messed up.  Stopping right now!!!!"
    exit 1
else
    echo "HOME is defined."
fi

# Make sure we have an SSH key just in case somebody needs it to set up a personal GitHub.Com
# account in the following step:
SSH_KEY_FILE=$HOME/.ssh/id_rsa
if [ -f "$SSH_KEY_FILE" ]
then
    echo "Secure shell encryption key previously generated."
else
    # Since, we don't want any prompting from `ssh-keygen`, see the URL below:
    # https://stackoverflow.com/questions/43235179/how-to-execute-ssh-keygen-without-prompt/45031320
    echo "**************** Creating an secure shell encryption key ..."
    ssh-keygen -q -t rsa -N '' -f $SSH_KEY_FILE 2>/dev/null <<< y >/dev/null
fi

# For the `dev` option, ensure that `GITHUB_ACCOUNT_NAME` is defined; otherwise immediately stop:
if [ -n "$DEV" ] &&  [ -z "${GITHUB_ACCOUNT_NAME+EXISTS}" ]
then
    echo "When the \`dev\` (or \`all\`) option is specified, you must have previously created"
    echo "a personal GitHub.Com account.  Furthermore, you need to install your copy your public"
    echo "SSH key up to your GitHub.Com account.  This script has already ensured that the file"
    echo "\`$SSH_KEY_FILE\` has been filled with your public SSH key.  Please visit and URL"
    echo "immediately below to finish the task of copying your public SSH key up to GitHub.Com:"
    echo ""
    echo "https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh"
    echo ""
    echo "After you have installed your public SSH key into your GitHub.Com account, next you need"
    echo "to define the \`GITHUB_ACCOUNT_NAME\` environment variable by adding a line near the end"
    echo "of your \`~/.bashrc\` that file that looks like:"
    echo ""
    echo "    export GITHUB_ACCOUNT_NAME=\"...\""
    echo ""
    echo "where ... is your personal GitHub.Com account name."
    echo ""
    echo "Finally, please type:"
    echo ""
    echo "    source ~/.bashrc"
    echo ""
    echo "to force the bash shell to pick up the \`GITHUB_ACCOUNT_NAME\` environment variable."
    echo "You can verify that it 'took' by typing:"
    echo ""
    echo "    echo \$GITHUB_ACCOUNT_NAME"
    echo ""
    echo "After all of that you can rerun the this command again."
    echo "Stopping now so you can do the steps immediately above."
    exit 1
fi

# Define some commonly used commands
SUDO="sudo -H"
APT_ADD_REPOSITORY="$SUDO add-apt-repository --yes"
APT_INSTALL="$SUDO apt install --yes"
APT_UPDATE="$SUDO apt update"
PIP_INSTALL="pip3 install"

# Define a couple more directories/files:
BASHRC="$HOME/.bashrc"
WORKON_HOME="$HOME/.virtualenvs"

# See if we need to install the Stm32CubeIde:
STM32_CUBE_IDE_DIRECTORY=$REPOSITORIES_DIRECTORY/stm32cubeide_1.3.0
STM32_CUBE_IDE_INSTALL_SH=$STM32_CUBE_IDE_DIRECTORY/install.sh
TMP_STM32_CUBE_IDE_SH=/tmp/stm32cubeide.sh
if [ -n "$EE$SW" ]
then
    # Determine if we need to download the `stm32cubeide` repository:
    if [ ! -d $STM32_CUBE_IDE_DIRECTORY ]
    then
	# Warn about the long download time, `sudo`, and license agreements."
	echo "**************** Installing Stm32CubeIDE repository to $STM32_CUBE_IDE_DIRECTORY ..."
	echo "This can take a very long time (15-30 minutes) ..."
        ( cd $REPOSITORIES_DIRECTORY ; \
	  git clone https://github.com/waynegramlich/stm32cubeide_1.3.0.git )
	echo "\`$STM32_CUBE_IDE_DIRECTORY\` repository is FINALLY downloaded."
        echo "Executing \`$STM32_CUBE_IDE_DIRECTORY\` pre-install script."
	( cd $STM32_CUBE_IDE_DIRECTORY ; $SUDO ./install.sh )
    else
	echo "Stm32CubeIDE 1.3.0 has been previously downloaded."
    fi
fi

# Tell the user that `sudo` is about to be used to install stuff:
# Warn the user about the possible upcoming sudo password prompt:
echo ""
echo "The \`sudo\` command is used to allow installation of system software."
echo "The vast majority of this software is installed via \`sudo\` atp install ...\`"
echo "\`sudo\` dpkg -i ...\`  Some packages like ROS and KiCAD are installed from"
echo "Personal Package Archives (typically called PPA's).  These packages get"
echo "regularly updated by the system.  The \`sudo\` command is also needed to"
echo "install the PPA's.  At this point \`sudo\` is going to be triggered and it will"
echo "prompt you for your user password to perform these system installs."
echo ""
$SUDO echo "Enable \`sudo\`..."
echo ""
echo "Unless your network download link is really slow, \`sudo\` will probably not bother you"
echo "for a password again.  If it does, just type it in again."
echo ""

# Finish the installation of the `stm32cubeide` software:
OPT_STM32_CUBE_IDE_DIRECTORY="/opt/st/stm32cubeide_1.3.0"
OPT_STM32_CUBE_IDE_EXECUTABLE="$OPT_STM32_CUBE_IDE_DIRECTORY/stm32cubeide"
if [ -n "$EE$SW" ] && [ ! -x "$OPT_STM32_CUBE_IDE_EXECUTABLE" ]
then
    # Just to be sure, we need to verify that STM32_CUBE_IDE_DIRECTORY actually exists.
    # It really should, since we should have downloaded that repository a little bit earlier.
    if [ ! -d "$STM32_CUBE_IDE_DIRECTORY" ]
    then
	echo "This is weird.  The \`$STM32_CUBE_IDE_DIRECTORY/\` should have been previously"
	echo "downloaded.  Stopping the script now."
	exit 1
    fi

    # See whether or not we need to run the installation script:
    if [ ! -x "$OPT_STM32_CUBE_IDE_EXECUTABLE" ]
    then
	# The executable has not been installed.
        TMP_STM32_CUBE_IDE_SH="/tmp/stm32cubeide.sh"
	if [ ! -x "$TMP_STM32_CUBE_IDE_SH" ]
	then
	    echo "Running \`$STM32_CUBE_IDE_DIRECTORY/install.sh\` ..."
	    ( cd "$STM32_CUBE_IDE_DIRECTORY" ; ./install.sh )
	    if [ ! -x "$TMP_STM32_CUBE_IDE_SH" ]
	    then
		echo "This is weird.  The file \`$TMP_STM32_CUBE_IDE_SH\` should now exist"
		echo "and it does not.  Stopping the script now."
	    fi
	fi

	# Now execute the `$TMP_STM32_CUBE_IDE_SH`.  This should do the license prompts and
	# install everything:
	echo "Executing \`$SUDO $TMP_STM32_CUBE_IDE_SH\` ..."
	$SUDO $TMP_STM32_CUBE_IDE_SH

	# Verify that the executable got installed:
	if [ ! -x "$OPT_STM32_CUBE_IDE_EXECUTABLE" ]
	then
	    echo "This is weird the executable \`$OPT_STM32_CUBE_IDE_EXECUTABLE\` should now exist"
	    echo "and it does not.  Stopping the script now."
	    exit 1
	fi
    else
	echo "Stm32CubeIDE Installation scripts previously executed."
    fi

    # See whether the link from the $HR2_DIRECTORY/bin directory has been installed:
    STM32_CUBE_IDE_LINK=$BIN_DIRECTORY/stm32cubeide
    if [ ! -L $STM32_CUBE_IDE_LINK ]
    then
	echo "**************** Installing a symbolic link to Stm32CubeIDE executable."
	rm -f $STM32_CUBE_IDE_LINK
	ln -s $OPT_STM32_CUBE_IDE_EXECUTABLE $STM32_CUBE_IDE_LINK
    else
	echo "Symbolic link to Stm32CubeIDE executable previously installed."
    fi
fi

# Below is the stuff we always want to be sure is installed.

# Make sure we have the Ubuntu build-essential package installed (mostly to get make).
if [ -z `which make` ]
then
    echo "**************** Installing Ubuntu build-essential package ..."
    $APT_INSTALL build-essential
else
    echo "Ubuntu build-essential package previously installed."
fi

# Make sure we have Ubuntu git package installed for version control management.
if [ -z `which git` ]
then
    # Frankly, we should never execute this, since we test for git earlier in the script,
    # but just in case, it never hurts to be certain...
    echo "**************** Installing Ubuntu git package for version control management ..."
    $APT_INSTALL git
else
    echo "Ubuntu git package for version control management previously installed."
fi

# Make sure we have Ubuntu vim package for vim the editor installed.
if [ -z "$(which vim)" ]
then
    echo "**************** Installing Ubuntu vim package for the vim editor ..."
    $APT_INSTALL vim
else
    echo "Ubuntu vim package for the vim editor previously installed"
fi

# Make sure we have Ubuntu emacs package for the emacs editor installed.
if [ -z "$(which emacs)" ]
then
    echo "**************** Installing ubuntu emacs package for the emacs editor ..."
    $APT_INSTALL emacs
else
    echo "The Ubuntu emacs package editor of emacs editor previously installed"
fi

# Do the first batch of Python configuration up front.  The second batch involves setting up
# the actual Python virtual environment and using it, that must be done at the end.
if [ -n "$PYTHON_NEEDED" ]
then
    # Force Python3 to be the default Python.  Python2 is the default Python until
    # Ubuntu 20.04 gets released.  We compute PYTHON_REALPATH and PYTHON3_REALPATH
    # and if they are not equal, we force an update.
    PYTHON_PATH="$(which python)"
    PYTHON3_PATH="$(which python3)"
    PYTHON_REALPATH="$(realpath $PYTHON_PATH)"
    PYTHON3_REALPATH="$(realpath $PYTHON3_PATH)"
    if [ "$PYTHON_REALPATH" != "$PYTHON3_REALPATH" ]
    then
	echo "**************** Forcing Python3 to be the default Python ..."
	sudo update-alternatives --install /usr/bin/python python $PYTHON3_REALPATH 2
    else
	echo "Python3 is already the default Python."
    fi

    # Install Ubuntu python3_pip3 package:
    if [ -z "#$(which pip3)" ]
    then
	echo "**************** Installing Ubuntu python3-pip package ..."
	$APT_INSTALL python3-pip
    else
	echo "Ubuntu python3-pip package previously installed."
    fi

    # Globally install Python virtual environments.  This is installation only, we do not use
    # them until much later on.  These means that we can leave debugging commands turned on for now.
    if [ -z "`which virtualenvwrapper.sh`" ]
    then
	echo "**************** Globally Installing Python virtual environments ..."
	$SUDO $PIP_INSTALL virtualenvwrapper
	if [ -z "`which virtualenvwrapper.sh`" ]
	then
	    echo "For some reason \`virtualenvwrapper.sh\` was not installed."
	    echo "There is no way to recover from this.  The script is stopping now."
	    exit 1
	fi
    else
	echo "Python virtual environments previously installed"
    fi

    # Modify ~/.bashrc to support virtual environments by appending the following to ~/.bashrc :
    #        export VIRTUALENVWRAPER_PYTHON=/usr/bin/python3
    #        export WORKON_HOME=$HOME/.virtualenvs
    #        export REPOSITORIES_DIRECTORY=...  # Root projects directory
    #        export VIRTUALENVWRAPER_WORKON_CD=1
    #        source /usr/local/bin/virtualenvwrapper.sh
    # Again, this is just setup, the actual virtual environment has not been created yet.

    # Append "export VIRTUALENVWRAPER_PYTHON=/user/bin/python3" to ~/.bashrc .
    if [ -z "`grep VIRTUALENVWRAPER_PYTHON $BASHRC`" ]
    then
	echo "**************** Add VIRTUALENVWRAPER_PYTHON to $BASHRC ..."
	echo "export VIRTUALENVWRAPER_PYTHON=`which python3`" >> $BASHRC
    else
	echo "VIRTUALENVWRAPER_PYTHON already in $BASHRC ."
    fi

    # Also ensure that it is locally defined:
    export VIRTUALENVWRAPER_PYTHON="$(which python3)"

    # Append "export WORKON_HOME=$HOME/.virtualenvs" to ~/.bashrc .
    if [ -z "`grep WORKON_HOME $BASHRC`" ]
    then
	echo "**************** Add WORKON_HOME to \`$BASHRC\` ..."
	echo "export WORKON_HOME=$WORKON_HOME" >> $BASHRC
    else
	echo "WORKON_HOME is already in \`$BASHRC\` ."
    fi
    # Also ensure that it is locally defined:
    export WORKON_HOME="$WORKON_HOME"

    # Append "**************** export REPOSITORIES_DIRECTORY=... " to `~/.bashrc` .
    if [ -z "`grep REPOSITORIES_DIRECTORY $BASHRC`" ]
    then
	echo "**************** Add REPOSITORIES_DIRECTORY to \`$BASHRC\` ..."
	echo "export REPOSITORIES_DIRECTORY=$REPOSITORIES_DIRECTORY" >> $BASHRC
    else
	echo "REPOSITORIES_DIRECTORY is already in \`$BASHRC\` ."
    fi
    # Also ensure it is defined locally:
    export REPOSITORIES_DIRECTORY="$REPOSITORIES_DIRECTORY"

    # Append "export VIRTUALENVWRAPER_WORKON_CD=1" to `~/.bashrc`.
    if [ -z "`grep VIRTUALENVWRAPER_WORKON_CD $BASHRC`" ]
    then
	echo "**************** Add VIRTUALENVWRAPER_WORKON_CD to \`$BASHRC\` ..."
	echo "export VIRTUALENVWRAPER_WORKON_CD=1" >> $BASHRC
    else
	echo "VIRTUALENVWRAPER_WORKON_CD already in \`$BASHRC\` ."
    fi
    # Also ensure it is defined locally:
    export VIRTUALENVWRAPER_WORKON_CD=1

    # Append "source /usr/local/bin/virtualenvwrapper.sh" to ~/.bashrc :
    if [ -z "`which virtualenvwrapper.sh $BASHRC`" ]
    then
	echo "**************** Add 'source .../virtualenvwrapper.sh' to $BASHRC ..."
	echo "source `which virtualenvwrapper.sh`" >> $BASHRC
    else
	echo "source `which virtualenvwrapper.sh` is already in $BASHRC ."
    fi

    # Remember to ask the user to `source ~/.bashrc`:
    SOURCE_BASHRC="yes"
fi

# Make sure that the $BIN_DIRECTORY is added to the the $PATH in $BASHRC:
echo "BIN_DIRECTORY=$BIN_DIRECTORY"
if [ -z "`grep :$BIN_DIRECTORY: $BASHRC`" ]
then 
    echo "**************** Adding $HR2_DIRECTORY/bin to PATH in \`$BASHRC\` ..."
    echo "# Only add $BIN_DIRECTORY to PATH once:" >> $BASHRC
    echo "case \":$PATH:\" in" >> $BASHRC
    echo "  *:$BIN_DIRECTORY:*) ;; # Already in path, do nothing " >> $BASHRC
    echo "  *) export PATH=\$PATH:$BIN_DIRECTORY ;; # Not in path, append it" >> $BASHRC
    echo "esac" >> $BASHRC
    echo "" >> $BASHRC
    SOURCE_BASHRC="yes"
else
    echo "$BIN_DIRECTORY was previously added to \`PATH\` in \`$BASHRC\`."
fi

# Make sure that no pushing to upstream or origin can occur:
PRE_PUSH=.git/hooks/pre-push
if [ ! -x $PRE_PUSH ]
then
    echo "**************** Disallow pushes to remote repository named upstream ..." >  $PRE_PUSH
    echo "#!/bin/bash"                                                              >> $PRE_PUSH
    echo "# Prevent pushes to remote repository named upstream."                    >> $PRE_PUSH
    echo "# Incoming shell arguments $1=remote_name $2=remote_url"                  >> $PRE_PUSH
    echo "if [ \"\$1\" = \"upstream\" ] || [ \"\$1\" = \"origin\" ];"               >> $PRE_PUSH
    echo "then"                                                                     >> $PRE_PUSH
    echo "    echo \"git push to remote repository named upstream or origin"\
	 "is disallowed.\""                                                         >> $PRE_PUSH
    echo "    echo \"Please do development in another git branch.\""                >> $PRE_PUSH
    echo "    exit 1"                                                               >> $PRE_PUSH
    echo "fi"                                                                       >> $PRE_PUSH
    chmod +x $PRE_PUSH
else
    echo "Pushes to remote repository named upstream have been previously disabled."
fi

# Make sure that the master branch disallows commits to the master branch.
PRE_COMMIT=.git/hooks/pre-commit
if [ ! -x $PRE_COMMIT ]
then
    echo "**************** Ensure that commits can not be performed on the master branch ..."
    echo "#!/bin/bash"                                               >  $PRE_COMMIT
    echo "branch=\"$(git rev-parse --abbrev-ref HEAD)\""             >> $PRE_COMMIT
    echo "if [ \"\$branch\" = \"master\" ]"                          >> $PRE_COMMIT
    echo "then"                                                      >> $PRE_COMMIT
    echo "    echo \"You can not commit directly to master branch\"" >> $PRE_COMMIT
    echo "    exit 1"                                                >> $PRE_COMMIT
    echo "fi"                                                        >> $PRE_COMMIT
    chmod +x $PRE_COMMIT
else
    echo "Commits were previously disallowed on the master branch."
fi

# Install `hub` program for interfacing with GitHub.Com:
if [ -z "$(which hub)" ]
then
    echo "**************** Installing hub program to interface with GitHub.Com ..."
    if [ -z "$(which snap)" ]
    then
	echo "The snap command is not installed.  This should not happen.  Given that it"
	echo "has happened, this script will immediately stop."
	exit 1
    fi
    $SUDO snap install hub --classic
else
    echo "hub program was previously installed."
fi

# Do any requested development installation:
if [ -n "$DEV" ]
then
    # We would have failed earlier if `GITHUB_ACCOUNT_NAME1 was not defines.
    # echo "We have a GitHub.Com account name $GITHUB_ACCOUNT_NAME ."
    # Make sure that we have a staging remote:
    if [ -z "$STAGING_REMOTE" ]
    then
	echo "**************** Creating a remote staging repository fork on GigHub.Com ..."
	echo "You may be prompted password to the GitHub.Com account named $GITHUB_ACCOUNT_NAME..."
	# As a side effect, the `hub fork` command creates the `staging` remote:
	hub fork --remote-name staging --org "$GITHUB_ACCOUNT_NAME"
        STAGING_REMOTE="staging"
    else
	echo "A project fork for staging was previously created on GitHub.Com."
    fi

    # Make sure that `upstream` remote exists:
    if [ -z "$UPSTREAM_REMOTE" ]
    then
        echo "**************** Installing \`git\` remote named \`upstream\`" \
	     "for \`$HR2_DIRECTORY\` ..."
	git remote add upstream "git@github.com:hbrobotics/hbrc_ros_robot_platform"
        UPSTREAM_REMOTE="upstream"
	# For some reason neither of these work:
	# git remote set-head upstream -a
	# git branch --set-upstream-to=upstream/master master
    fi

    # Remove any `origin` upstream:
    if [ -n "$UPSTREAM_REMOTE" ] && [ -n "$ORIGIN_REMOTE" ]
    then
	echo "**************** Removing \`git\` remote named \`origin\` for \`$HR2_DIRECTORY\` ..."
	git remote remove origin
	ORIGIN_REMOTE=""
    else
	echo "\`git\` remote named \`origin\` was previously removed."
    fi
fi

# Make sure markdown to HTML converter is installed:
if [ -z "`which markdown`" ]
then
    echo "**************** Installing markdown to HTML converter ..."
    $APT_INSTALL markdown
else
    echo "markdown to HTML converter previously installed."
fi

# Install mechanical engineering tools:
if [ -n "$ME" ]
then
   # Make sure we have openscad installed:
   if [ -z "`which openscad`" ]
   then
       # While there is no standard openscad package for 18.04 or 18.10, there is one for 19.10.
       # We side step the issue by just grabbing openscad directly from the openscad repository.
       echo "**************** Installing openscad package ..."
       $APT_ADD_REPOSITORY ppa:openscad/releases
       $APT_UPDATE
       $APT_INSTALL openscad
   else
       echo "openscad previously installed."
   fi
    
   # Make sure that qcad is installed:
   if [ -z "`which qcad`" ]
   then
       echo "**************** Installing qcad package ..."
       $APT_ADD_REPOSITORY ppa:alex-p/qcad
       $APT_UPDATE
       $APT_INSTALL qcad
   else
       echo "qcad previously installed"
   fi
fi

# Install Electrical Engineering tools:
if [ -n "$EE" ]
then
    # Install kicad:
    if [ -z "$(which kicad)" ]
    then
	echo "**************** Installing KiCad package ..."
	echo "Add KiCad to your package repository database:"
	$SUDO add-apt-repository --yes ppa:js-reynaud/kicad-5.1
	echo "Update your package repository database:"
	$APT_UPDATE
	echo "Install kicad. This over a gigabyte of code/libraires to download ..."
	$APT_INSTALL --install-recommends kicad
	echo "Install KiCad demo projects:"
	$APT_INSTALL kicad-demo
    else
	echo "Kicad previously installed"
    fi

    # Clone bom_manager:
    if [ ! -d $REPOSITORIES_DIRECTORY/bom_manager ]
    then
	echo "**************** Cloning bom_manager repository into $REPOSITORIES_DIRECTORY ."
	echo REPOSITORIES_DIRECTORY=$REPOSITORIES_DIRECTORY
	(cd $REPOSITORIES_DIRECTORY ; git clone https://github.com/waynegramlich/bom_manager.git)
    else
	echo "Making sure that bom_manager is up to date ..."
	( cd $REPOSITORIES_DIRECTORY/bom_manager ; $GIT_PULL )
    fi

    # Clone kicube32:
    if [ ! -d $REPOSITORIES_DIRECTORY/kicube32 ]
    then
	echo REPOSITORIES_DIRECTORY=$REPOSITORIES_DIRECTORY
	echo "**************** Cloning kicube32 repository into $REPOSITORIES_DIRECTORY ."
	( cd $REPOSITORIES_DIRECTORY ; git clone https://github.com/waynegramlich/kicube32.git )
    else
	echo "Making sure that kicube32 is up to date ..."
	( cd $REPOSITORIES_DIRECTORY/kicube32 ; $GIT_PULL )
    fi
fi

# Install the Python stuff for both ME and EE:
if [ -n "$PYTHON_NEEDED" ]
then
    if [ -z "`which virtualenvwrapper.sh`" ]
    then
	echo "For some reasons virtualenvwrapper.sh did not get installed.  This is bad."
	echo "It is sufficiently bad that this script can not continue.  Stopping script now."
        exit 1
    fi

    # The virtual wrapper script breaks under debugging, so turn all debugging is now turned off.
    set +x           # Trace execution.
    set +e           # Exit immediately on error result.
    set +o pipefail  # Fail if any commands in a pipeline fail.
    set +u           # Treat unset variables as an error.

    # We should have a hot Python virtual environment:
    source "`which virtualenvwrapper.sh`"

    # Now ensure that the hr2 Python virtual environment exists:
    MKVIRTUALENV="mkvirtualenv -p 3.6" 
    if [ ! -d $WORKON_HOME/hr2 ]
    then
	echo "**************** Create hr2 python virtual environment ..."
	$MKVIRTUALENV -a $HR2_DIRECTORY hr2
    else
	echo "hr2 Python virtual environment already exists."
    fi

    # For some weird reason, doing a "source $BASHRC" does not properly get
    # the virtual environment wrapper variables set properly.  So, instead
    # we set them all manually below:
    export VIRTUALENVWRAPER_PYTHON="$(which python3)"
    export WORKON_HOME=$WORKON_HOME
    export REPOSITORIES_DIRECTORY=$REPOSITORIES_DIRECTORY
    export VIRTUALENVWRAPER_WORKON_CD=1

    # Python virtual environments are not recursive.  This means that if one has been activated
    # that we should not attempt to activate another.  We deal with all of this complexity with
    # the shell function below.
    # Usage `hr2_env_pip_install ENV_NAME PROGRAM_NAME_OR_DIRECTORY`
    # `ENV_NAME` is the virtual environment name, and
    # `PROGRAM_NAME_OR_DIRECTORY` is the program name or Python directory to be installed
    function python_env_pip_install() {
	# Exactly two arguments are required:
	if [ "$#" != "2" ]
	then
	    echo "\`python_env_pip_install\` called with $# arguments instead of just 2."
	    return 1
	fi

	# Extract the arguments and give them names:
	ENV_NAME="$1"
	PROGRAM_NAME_OR_DIRECTORY="$2"

	# Make sure there is an `ENV_DIRECTORY` exists:
        ENV_DIRECTORY="$WORKON_HOME/$ENV_NAME"
	if [ ! -d "$ENV_DIRECTORY" ]
	then
	    echo "\`$ENV_DIRECTORY\` does not exist."
	    return 2
	fi
	
        # Figure out if the ENV_NAME is active or not:
	if [ -z "${VIRTUAL_ENV+EXISTS}" ]
	then
	    # `VIRTUAL_ENV` is not enabled, so we can activate one, install and deactivate:
	    (workon "$ENV_NAME"
	     $PIP_INSTALL "$PROGRAM_NAME_OR_DIRECTORY"
	     deactivate)
	else
	    # `VIRTUAL_ENV` is enabled.

	    # There is an active environment, but doe it match `ENV_NAME`?
	    ACTUAL_ENV_NAME="$(echo $VIRTUAL_ENV | sed "s,^.*/,,g")"
	    if [ "$ACTUAL_ENV_NAME" != "$ENV_NAME" ]
	    then
		echo "Currently active Python virtual environment is" \
		     "\`$ACTUAL_ENV_NAME\` not \`$ENV_NAME\`."
		return 3
	    fi
	    
	    # We can just do a simple `PIP_INSTALL`:
	    $PIP_INSTALL "$PROGRAM_NAME_OR_DIRECTORY"
	fi
    }

    # Install Python mypi static type checker:
    python_env_pip_install hr2 mypy

    # Install Python flake8 code style checker:
    python_env_pip_install hr2 flake8

    # Install Python pydocstyle documentation style checker:
    python_env_pip_install hr2 pydocstyle

    # Install pytest testing system:
    python_env_pip_install hr2 pytest

    # Install kipart, kicube32, bom_manager for EE:
    if [ -n "$EE" ]
    then
	# Install kipart into hr2 environment:
        python_env_pip_install hr2 kipart

	# Install kicube32 into hr2 environment:
        KICUBE32_DIRECTORY="$REPOSITORIES_DIRECTORY/kicube32"
        python_env_pip_install hr2 "$KICUBE32_DIRECTORY"

	# For now do not bother with `bom_manager`.
    fi
fi

# Remind the user to update their top-level `bash` environment:
if [ -n "$SOURCE_BASHRC" ]
then
    echo "Please type \`source ~/.bashrc\` after this to update your environment."
fi

# Remind the user to activate the `hr2` python virtual environment:
if [ -n "$PYTHON_NEEDED" ]
then
    echo "Please type \`workon hr2\` to activate your Python virtual environment."
fi
